<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>StreamLabs Chicken</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: transparent;
        }
        #chicken {
            position: absolute;
            width: 300px; /* Smaller default size for StreamLabs */
            height: 300px;
            transition: transform 0.3s ease;
        }
    </style>
</head>
<body>
    <svg id="chicken" viewBox="0 0 800 800" xmlns="http://www.w3.org/2000/svg">
        [Previous SVG content remains exactly the same]
    </svg>

    <script>
        const chicken = document.getElementById('chicken');
        const upperBeak = document.getElementById('upperBeak');
        const lowerBeak = document.getElementById('lowerBeak');
        const head = document.getElementById('head');
        let audioContext;
        let analyser;
        let dataArray;
        
        // Start audio processing immediately
        async function initAudio() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: true,
                    video: false // Explicitly disable video
                });
                
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 1024;
                
                const source = audioContext.createMediaStreamSource(stream);
                source.connect(analyser);
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                
                // Start animations
                animate();
                startBehaviors();
                
            } catch (err) {
                console.error('Microphone error:', err);
                // Try again in 3 seconds if failed
                setTimeout(initAudio, 3000);
            }
        }

        // Initialize behaviors
        let currentBehavior = 'idle';
        const behaviors = {
            idle: { duration: 2000, next: ['lookLeft', 'lookRight', 'walkLeft', 'walkRight', 'peck'] },
            lookLeft: { duration: 1500, next: ['idle', 'walkLeft', 'peck'] },
            lookRight: { duration: 1500, next: ['idle', 'walkRight', 'peck'] },
            walkLeft: { duration: 3000, next: ['idle', 'lookLeft', 'peck'] },
            walkRight: { duration: 3000, next: ['idle', 'lookRight', 'peck'] },
            peck: { duration: 1000, next: ['idle', 'walkLeft', 'walkRight'] }
        };

        function startBehaviors() {
            updateBehavior();
        }

        function updateBehavior() {
            const possibleNext = behaviors[currentBehavior].next;
            currentBehavior = possibleNext[Math.floor(Math.random() * possibleNext.length)];
            setTimeout(updateBehavior, behaviors[currentBehavior].duration);
        }

        function performBehavior(volume) {
            const progress = (Date.now() % behaviors[currentBehavior].duration) / behaviors[currentBehavior].duration;
            
            switch(currentBehavior) {
                case 'lookLeft':
                    head.style.transform = `rotate(${-20 * Math.sin(Math.PI * progress)}deg)`;
                    break;
                    
                case 'lookRight':
                    head.style.transform = `rotate(${20 * Math.sin(Math.PI * progress)}deg)`;
                    break;
                    
                case 'walkLeft':
                    chicken.style.transform = 'scaleX(-1)';
                    chicken.style.left = `${Math.max(0, (progress * -200) + window.innerWidth/2)}px`;
                    head.style.transform = `rotate(${5 * Math.sin(progress * Math.PI * 4)}deg)`;
                    break;
                    
                case 'walkRight':
                    chicken.style.transform = 'scaleX(1)';
                    chicken.style.left = `${Math.min(window.innerWidth - 300, (progress * 200) + window.innerWidth/2)}px`;
                    head.style.transform = `rotate(${5 * Math.sin(progress * Math.PI * 4)}deg)`;
                    break;
                    
                case 'peck':
                    const pecking = progress > 0.4 && progress < 0.6;
                    head.style.transform = `rotate(${30 * Math.sin(Math.PI * progress)}deg) translateY(${20 * Math.sin(Math.PI * progress)}px)`;
                    if (pecking) {
                        upperBeak.setAttribute('d', `M260 140 L210 130 L260 140`);
                        lowerBeak.setAttribute('d', `M260 140 L210 150 L260 140`);
                    } else {
                        upperBeak.setAttribute('d', 'M260 140 L210 135 L260 140');
                        lowerBeak.setAttribute('d', 'M260 140 L210 145 L260 140');
                    }
                    break;
            }
        }

        function animate() {
            if (!analyser) return requestAnimationFrame(animate);
            
            analyser.getByteFrequencyData(dataArray);
            const volume = dataArray.slice(10, 50).reduce((a, b) => a + b) / 40;
            
            // Audio-reactive beak movement
            if (volume > 30 && currentBehavior !== 'peck') {
                const beakOpen = Math.min(volume / 40, 10);
                upperBeak.setAttribute('d', `M260 140 L210 ${135 - beakOpen} L260 140`);
                lowerBeak.setAttribute('d', `M260 140 L210 ${145 + beakOpen} L260 140`);
            }
            
            performBehavior(volume);
            requestAnimationFrame(animate);
        }

        // Start immediately - no button needed
        initAudio();
    </script>
</body>
</html>
